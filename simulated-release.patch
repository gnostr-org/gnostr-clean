diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..26a1e03
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,51 @@
+name: CI
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    branches: [ master ]
+
+jobs:
+  build:
+    name: Rust (${{ matrix.rust }}) (${{ matrix.os }})
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os:
+          - macos-latest
+          - ubuntu-latest
+          - windows-latest
+        rust:
+          - stable
+          - beta
+          - nightly
+
+    steps:
+      - uses: actions/checkout@v2
+
+      - uses: actions-rs/toolchain@v1
+        with:
+          profile: minimal
+          toolchain: ${{ matrix.rust }}
+          override: true
+          components: rustfmt, clippy
+
+      - uses: actions-rs/cargo@v1
+        with:
+          command: build
+
+      - uses: actions-rs/cargo@v1
+        with:
+          command: test
+
+      - uses: actions-rs/cargo@v1
+        with:
+          command: fmt
+          args: --all -- --check
+
+      - uses: actions-rs/cargo@v1
+        with:
+          command: clippy
+          args: --all --all-features --profile test
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..8817ead
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,5 @@
+/target
+/Cargo.lock
+/**/*.rs.bk
+.nvmrc
+.gnostr/proxy
diff --git a/.justfile b/.justfile
new file mode 100644
index 0000000..4616260
--- /dev/null
+++ b/.justfile
@@ -0,0 +1,63 @@
+default:
+  just --choose
+
+help:
+  @make help
+
+all:
+  @make all
+
+bin:
+  @make bin
+
+cargo-help:
+  @make cargo-help
+
+cargo-release-all:
+  @make cargo-release-all
+
+cargo-clean-release:
+  @make cargo-clean-release
+
+cargo-publish-all:
+  @make cargo-publish-all
+
+cargo-install-bins:
+  @make cargo-install-bins
+
+cargo-build:
+  @make cargo-build
+
+cargo-install:
+  @make cargo-install
+
+cargo-build-release:
+  @make cargo-build-release
+
+cargo-check:
+  @make cargo-check
+
+cargo-bench:
+  @make cargo-bench
+
+cargo-test:
+  @make cargo-test
+
+cargo-test-nightly:
+  @make cargo-test-nightly
+
+cargo-report:
+  @make cargo-report
+
+cargo-run:
+  @make cargo-run
+
+cargo-dist:
+  @make cargo-dist
+
+cargo-dist-build:
+  @make cargo-dist-build
+
+cargo-dist-manifest:
+  @make cargo-dist-manifest
+
diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 0000000..e9e6f5b
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,1276 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 4
+
+[[package]]
+name = "aho-corasick"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "android-tzdata"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
+
+[[package]]
+name = "android_system_properties"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "anstream"
+version = "0.6.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b"
+dependencies = [
+ "anstyle",
+ "anstyle-parse",
+ "anstyle-query",
+ "anstyle-wincon",
+ "colorchoice",
+ "is_terminal_polyfill",
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle"
+version = "1.0.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9"
+
+[[package]]
+name = "anstyle-parse"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9"
+dependencies = [
+ "utf8parse",
+]
+
+[[package]]
+name = "anstyle-query"
+version = "1.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c"
+dependencies = [
+ "windows-sys",
+]
+
+[[package]]
+name = "anstyle-wincon"
+version = "3.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca3534e77181a9cc07539ad51f2141fe32f6c3ffd4df76db8ad92346b003ae4e"
+dependencies = [
+ "anstyle",
+ "once_cell",
+ "windows-sys",
+]
+
+[[package]]
+name = "assert_cmd"
+version = "2.0.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dc1835b7f27878de8525dc71410b5a31cdcc5f230aed5ba5df968e09c201b23d"
+dependencies = [
+ "anstyle",
+ "bstr",
+ "doc-comment",
+ "libc",
+ "predicates",
+ "predicates-core",
+ "predicates-tree",
+ "wait-timeout",
+]
+
+[[package]]
+name = "autocfg"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
+
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
+[[package]]
+name = "bitflags"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd"
+
+[[package]]
+name = "bstr"
+version = "1.11.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "531a9155a481e2ee699d4f98f43c0ca4ff8ee1bfd55c31e9e98fb29d2b176fe0"
+dependencies = [
+ "memchr",
+ "regex-automata",
+ "serde",
+]
+
+[[package]]
+name = "bumpalo"
+version = "3.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"
+
+[[package]]
+name = "cc"
+version = "1.2.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1fcb57c740ae1daf453ae85f16e37396f672b039e00d9d866e07ddb24e328e3a"
+dependencies = [
+ "jobserver",
+ "libc",
+ "shlex",
+]
+
+[[package]]
+name = "cfg-if"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
+
+[[package]]
+name = "chrono"
+version = "0.4.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a7964611d71df112cb1730f2ee67324fcf4d0fc6606acbbe9bfe06df124637c"
+dependencies = [
+ "android-tzdata",
+ "iana-time-zone",
+ "js-sys",
+ "num-traits",
+ "wasm-bindgen",
+ "windows-link",
+]
+
+[[package]]
+name = "clap"
+version = "4.5.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e958897981290da2a852763fe9cdb89cd36977a5d729023127095fa94d95e2ff"
+dependencies = [
+ "clap_builder",
+ "clap_derive",
+]
+
+[[package]]
+name = "clap_builder"
+version = "4.5.34"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "83b0f35019843db2160b5bb19ae09b4e6411ac33fc6a712003c33e03090e2489"
+dependencies = [
+ "anstream",
+ "anstyle",
+ "clap_lex",
+ "strsim",
+]
+
+[[package]]
+name = "clap_derive"
+version = "4.5.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09176aae279615badda0765c0c0b3f6ed53f4709118af73cf4655d85d1530cd7"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "clap_lex"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f46ad14479a25103f283c0f10005961cf086d8dc42205bb44c46ac563475dca6"
+
+[[package]]
+name = "colorchoice"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990"
+
+[[package]]
+name = "core-foundation-sys"
+version = "0.8.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
+dependencies = [
+ "crossbeam-epoch",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.9.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
+dependencies = [
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.8.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
+
+[[package]]
+name = "difflib"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6184e33543162437515c2e2b48714794e37845ec9851711914eec9d308f6ebe8"
+
+[[package]]
+name = "displaydoc"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "doc-comment"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10"
+
+[[package]]
+name = "either"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
+
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
+[[package]]
+name = "errno"
+version = "0.3.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
+dependencies = [
+ "libc",
+ "windows-sys",
+]
+
+[[package]]
+name = "fastrand"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
+
+[[package]]
+name = "form_urlencoded"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
+dependencies = [
+ "percent-encoding",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "73fea8450eea4bac3940448fb7ae50d91f034f941199fcd9d909a5a07aa455f0"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "r-efi",
+ "wasi",
+]
+
+[[package]]
+name = "git2"
+version = "0.17.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b989d6a7ca95a362cf2cfc5ad688b3a467be1f87e480b8dad07fee8c79b0044"
+dependencies = [
+ "bitflags 1.3.2",
+ "libc",
+ "libgit2-sys",
+ "log",
+ "openssl-probe",
+ "openssl-sys",
+ "url",
+]
+
+[[package]]
+name = "gitr"
+version = "0.1.2"
+dependencies = [
+ "assert_cmd",
+ "chrono",
+ "clap",
+ "git2",
+ "rayon",
+ "regex",
+ "serde",
+ "serde_json",
+ "tempfile",
+ "toml",
+ "walkdir",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
+
+[[package]]
+name = "heck"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"
+
+[[package]]
+name = "iana-time-zone"
+version = "0.1.62"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b2fd658b06e56721792c5df4475705b6cda790e9298d19d2f8af083457bcd127"
+dependencies = [
+ "android_system_properties",
+ "core-foundation-sys",
+ "iana-time-zone-haiku",
+ "js-sys",
+ "log",
+ "wasm-bindgen",
+ "windows-core",
+]
+
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
+dependencies = [
+ "cc",
+]
+
+[[package]]
+name = "icu_collections"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db2fa452206ebee18c4b5c2274dbf1de17008e874b4dc4f0aea9d01ca79e4526"
+dependencies = [
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13acbb8371917fc971be86fc8057c41a64b521c184808a698c02acc242dbf637"
+dependencies = [
+ "displaydoc",
+ "litemap",
+ "tinystr",
+ "writeable",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid_transform"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "01d11ac35de8e40fdeda00d9e1e9d92525f3f9d887cdd7aa81d727596788b54e"
+dependencies = [
+ "displaydoc",
+ "icu_locid",
+ "icu_locid_transform_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_locid_transform_data"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7515e6d781098bf9f7205ab3fc7e9709d34554ae0b21ddbcb5febfa4bc7df11d"
+
+[[package]]
+name = "icu_normalizer"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19ce3e0da2ec68599d193c93d088142efd7f9c5d6fc9b803774855747dc6a84f"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
+ "icu_provider",
+ "smallvec",
+ "utf16_iter",
+ "utf8_iter",
+ "write16",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_normalizer_data"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c5e8338228bdc8ab83303f16b797e177953730f601a96c25d10cb3ab0daa0cb7"
+
+[[package]]
+name = "icu_properties"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93d6020766cfc6302c15dbbc9c8778c37e62c14427cb7f6e601d849e092aeef5"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_locid_transform",
+ "icu_properties_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_properties_data"
+version = "1.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85fb8799753b75aee8d2a21d7c14d9f38921b54b3dbda10f5a3c7a7b82dba5e2"
+
+[[package]]
+name = "icu_provider"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ed421c8a8ef78d3e2dbc98a973be2f3770cb42b606e3ab18d6237c4dfde68d9"
+dependencies = [
+ "displaydoc",
+ "icu_locid",
+ "icu_provider_macros",
+ "stable_deref_trait",
+ "tinystr",
+ "writeable",
+ "yoke",
+ "zerofrom",
+ "zerovec",
+]
+
+[[package]]
+name = "icu_provider_macros"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ec89e9337638ecdc08744df490b221a7399bf8d164eb52a665454e60e075ad6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "idna"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
+dependencies = [
+ "idna_adapter",
+ "smallvec",
+ "utf8_iter",
+]
+
+[[package]]
+name = "idna_adapter"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "daca1df1c957320b2cf139ac61e7bd64fed304c5040df000a745aa1de3b4ef71"
+dependencies = [
+ "icu_normalizer",
+ "icu_properties",
+]
+
+[[package]]
+name = "indexmap"
+version = "2.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3954d50fe15b02142bf25d3b8bdadb634ec3948f103d04ffe3031bc8fe9d7058"
+dependencies = [
+ "equivalent",
+ "hashbrown",
+]
+
+[[package]]
+name = "is_terminal_polyfill"
+version = "1.70.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"
+
+[[package]]
+name = "itoa"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
+
+[[package]]
+name = "jobserver"
+version = "0.1.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "48d1dbcbbeb6a7fec7e059840aa538bd62aaccf972c7346c4d9d2059312853d0"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "js-sys"
+version = "0.3.77"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
+dependencies = [
+ "once_cell",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.171"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"
+
+[[package]]
+name = "libgit2-sys"
+version = "0.15.2+1.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a80df2e11fb4a61f4ba2ab42dbe7f74468da143f1a75c74e11dee7c813f694fa"
+dependencies = [
+ "cc",
+ "libc",
+ "libssh2-sys",
+ "libz-sys",
+ "openssl-sys",
+ "pkg-config",
+]
+
+[[package]]
+name = "libssh2-sys"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "220e4f05ad4a218192533b300327f5150e809b54c4ec83b5a1d91833601811b9"
+dependencies = [
+ "cc",
+ "libc",
+ "libz-sys",
+ "openssl-sys",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "libz-sys"
+version = "1.1.22"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8b70e7a7df205e92a1a4cd9aaae7898dac0aa555503cc0a649494d0d60e7651d"
+dependencies = [
+ "cc",
+ "libc",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "linux-raw-sys"
+version = "0.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fe7db12097d22ec582439daf8618b8fdd1a7bef6270e9af3b1ebcd30893cf413"
+
+[[package]]
+name = "litemap"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "23fb14cb19457329c82206317a5663005a4d404783dc74f4252769b0d5f42856"
+
+[[package]]
+name = "log"
+version = "0.4.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"
+
+[[package]]
+name = "memchr"
+version = "2.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
+
+[[package]]
+name = "num-traits"
+version = "0.2.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
+name = "once_cell"
+version = "1.21.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c2806eaa3524762875e21c3dcd057bc4b7bfa01ce4da8d46be1cd43649e1cc6b"
+
+[[package]]
+name = "openssl-probe"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"
+
+[[package]]
+name = "openssl-sys"
+version = "0.9.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8bb61ea9811cc39e3c2069f40b8b8e2e70d8569b361f879786cc7ed48b777cdd"
+dependencies = [
+ "cc",
+ "libc",
+ "pkg-config",
+ "vcpkg",
+]
+
+[[package]]
+name = "percent-encoding"
+version = "2.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+
+[[package]]
+name = "pkg-config"
+version = "0.3.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"
+
+[[package]]
+name = "predicates"
+version = "3.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a5d19ee57562043d37e82899fade9a22ebab7be9cef5026b07fda9cdd4293573"
+dependencies = [
+ "anstyle",
+ "difflib",
+ "predicates-core",
+]
+
+[[package]]
+name = "predicates-core"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "727e462b119fe9c93fd0eb1429a5f7647394014cf3c04ab2c0350eeb09095ffa"
+
+[[package]]
+name = "predicates-tree"
+version = "1.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "72dd2d6d381dfb73a193c7fca536518d7caee39fc8503f74e7dc0be0531b425c"
+dependencies = [
+ "predicates-core",
+ "termtree",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.94"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "r-efi"
+version = "5.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74765f6d916ee2faa39bc8e68e4f3ed8949b48cccdac59983d287a7cb71ce9c5"
+
+[[package]]
+name = "rayon"
+version = "1.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
+dependencies = [
+ "either",
+ "rayon-core",
+]
+
+[[package]]
+name = "rayon-core"
+version = "1.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
+dependencies = [
+ "crossbeam-deque",
+ "crossbeam-utils",
+]
+
+[[package]]
+name = "regex"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-automata",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.4.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.8.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
+
+[[package]]
+name = "rustix"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e56a18552996ac8d29ecc3b190b4fdbb2d91ca4ec396de7bbffaf43f3d637e96"
+dependencies = [
+ "bitflags 2.9.0",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys",
+]
+
+[[package]]
+name = "rustversion"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2"
+
+[[package]]
+name = "ryu"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
+
+[[package]]
+name = "same-file"
+version = "1.0.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.140"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
+dependencies = [
+ "itoa",
+ "memchr",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "shlex"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
+
+[[package]]
+name = "smallvec"
+version = "1.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fcf8323ef1faaee30a44a340193b1ac6814fd9b7b4e88e9d4519a3e4abe1cfd"
+
+[[package]]
+name = "stable_deref_trait"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
+
+[[package]]
+name = "strsim"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"
+
+[[package]]
+name = "syn"
+version = "2.0.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "synstructure"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tempfile"
+version = "3.19.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7437ac7763b9b123ccf33c338a5cc1bac6f69b45a136c19bdd8a65e3916435bf"
+dependencies = [
+ "fastrand",
+ "getrandom",
+ "once_cell",
+ "rustix",
+ "windows-sys",
+]
+
+[[package]]
+name = "termtree"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f50febec83f5ee1df3015341d8bd429f2d1cc62bcba7ea2076759d315084683"
+
+[[package]]
+name = "tinystr"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9117f5d4db391c1cf6927e7bea3db74b9a1c1add8f7eda9ffd5364f40f57b82f"
+dependencies = [
+ "displaydoc",
+ "zerovec",
+]
+
+[[package]]
+name = "toml"
+version = "0.7.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dd79e69d3b627db300ff956027cc6c3798cef26d22526befdfcd12feeb6d2257"
+dependencies = [
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "toml_edit",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.19.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "winnow",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
+
+[[package]]
+name = "url"
+version = "2.5.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
+dependencies = [
+ "form_urlencoded",
+ "idna",
+ "percent-encoding",
+]
+
+[[package]]
+name = "utf16_iter"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8232dd3cdaed5356e0f716d285e4b40b932ac434100fe9b7e0e8e935b9e6246"
+
+[[package]]
+name = "utf8_iter"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"
+
+[[package]]
+name = "utf8parse"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
+
+[[package]]
+name = "vcpkg"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"
+
+[[package]]
+name = "wait-timeout"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ac3b126d3914f9849036f826e054cbabdc8519970b8998ddaf3b5bd3c65f11"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "walkdir"
+version = "2.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
+dependencies = [
+ "same-file",
+ "winapi-util",
+]
+
+[[package]]
+name = "wasi"
+version = "0.14.2+wasi-0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
+dependencies = [
+ "wit-bindgen-rt",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
+dependencies = [
+ "cfg-if",
+ "once_cell",
+ "rustversion",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
+dependencies = [
+ "bumpalo",
+ "log",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
+dependencies = [
+ "quote",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.100"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "winapi-util"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
+dependencies = [
+ "windows-sys",
+]
+
+[[package]]
+name = "windows-core"
+version = "0.52.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
+dependencies = [
+ "windows-targets",
+]
+
+[[package]]
+name = "windows-link"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76840935b766e1b0a05c0066835fb9ec80071d4c09a16f6bd5f7e655e3c14c38"
+
+[[package]]
+name = "windows-sys"
+version = "0.59.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
+dependencies = [
+ "windows-targets",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
+dependencies = [
+ "windows_aarch64_gnullvm",
+ "windows_aarch64_msvc",
+ "windows_i686_gnu",
+ "windows_i686_gnullvm",
+ "windows_i686_msvc",
+ "windows_x86_64_gnu",
+ "windows_x86_64_gnullvm",
+ "windows_x86_64_msvc",
+]
+
+[[package]]
+name = "windows_aarch64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
+
+[[package]]
+name = "windows_aarch64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
+
+[[package]]
+name = "windows_i686_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
+
+[[package]]
+name = "windows_i686_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
+
+[[package]]
+name = "windows_i686_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
+
+[[package]]
+name = "windows_x86_64_gnu"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
+
+[[package]]
+name = "windows_x86_64_gnullvm"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
+
+[[package]]
+name = "windows_x86_64_msvc"
+version = "0.52.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
+
+[[package]]
+name = "winnow"
+version = "0.5.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "wit-bindgen-rt"
+version = "0.39.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
+dependencies = [
+ "bitflags 2.9.0",
+]
+
+[[package]]
+name = "write16"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d1890f4022759daae28ed4fe62859b1236caebfc61ede2f63ed4e695f3f6d936"
+
+[[package]]
+name = "writeable"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51"
+
+[[package]]
+name = "yoke"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "120e6aef9aa629e3d4f52dc8cc43a015c7724194c97dfaf45180d2daf2b77f40"
+dependencies = [
+ "serde",
+ "stable_deref_trait",
+ "yoke-derive",
+ "zerofrom",
+]
+
+[[package]]
+name = "yoke-derive"
+version = "0.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2380878cad4ac9aac1e2435f3eb4020e8374b5f13c296cb75b4620ff8e229154"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
+[[package]]
+name = "zerofrom"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
+dependencies = [
+ "zerofrom-derive",
+]
+
+[[package]]
+name = "zerofrom-derive"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
+[[package]]
+name = "zerovec"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa2b893d79df23bfb12d5461018d408ea19dfafe76c2c7ef6d4eba614f8ff079"
+dependencies = [
+ "yoke",
+ "zerofrom",
+ "zerovec-derive",
+]
+
+[[package]]
+name = "zerovec-derive"
+version = "0.10.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6eafa6dfb17584ea3e2bd6e76e0cc15ad7af12b09abdd1ca55961bed9b1063c6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..a8b3970
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,24 @@
+[package]
+name = "gitr"
+version = "0.1.2" # remember to update html_root_url
+authors = ["gnostr gnostr@gnostr.org", "Isaac Whitfield <iw@whitfin.io>"]
+description = "Quickly clean up your development directories on disk"
+repository = "https://github.com/gnostr-org/gitr"
+keywords = ["backup", "compression", "clean"]
+categories = ["algorithms", "command-line-utilities", "filesystem"]
+readme = "README.md"
+edition = "2018"
+license = "MIT"
+
+[dependencies]
+assert_cmd = "2.0.10"
+chrono = "0.4"
+clap = { version = "4.2.4", features = ["derive"] }
+git2 = "0.17.1"
+rayon = "1.5.1"
+regex = "1.5.4"
+serde = { version = "1.0", features = ["derive"] }
+serde_json = "1.0"
+tempfile = "3.2.0"
+toml = "0.7.3"
+walkdir = "2.3.2"
diff --git a/GNUmakefile b/GNUmakefile
new file mode 100644
index 0000000..1252171
--- /dev/null
+++ b/GNUmakefile
@@ -0,0 +1,4 @@
+-:
+	cargo install --path . && gnostr-clean .
+
+-include Makefile
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..3477fcd
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2019 Isaac Whitfield
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..f3a1c76
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,82 @@
+help:
+	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?##/ {printf "\033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)
+	@echo
+
+##
+##===============================================================================
+##all
+## 	bin
+all: bin### all
+##bin
+## 	cargo b --manifest-path Cargo.toml
+bin:### bin
+	cargo b --manifest-path Cargo.toml
+
+##
+##===============================================================================
+##make cargo-*
+cargo-help:### cargo-help
+	@awk 'BEGIN {FS = ":.*?###"} /^[a-zA-Z_-]+:.*?###/ {printf "\033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)
+cargo-release-all:### cargo-release-all
+## 	cargo-release-all recursively cargo build --release
+	for t in */Cargo.toml;  do echo $$t; cargo b -r -vv --manifest-path $$t; done
+	for t in ffi/*/Cargo.toml;  do echo $$t; cargo b -r -vv --manifest-path $$t; done
+cargo-clean-release:### cargo-clean-release - clean release artifacts
+## 	cargo-clean-release 	recursively cargo clean --release
+	for t in *Cargo.toml;  do echo $$t && cargo clean --release -vv --manifest-path $$t 2>/dev/null; done
+cargo-publish-all:### cargo-publish-all
+## 	cargo-publish-all 	recursively publish rust projects
+	for t in *Cargo.toml;  do echo $$t; cargo publish -vv --manifest-path $$t; done
+
+cargo-install-bins:###  cargo-install-bins
+## 	cargo-install-all 	recursively cargo install -vv $(SUBMODULES)
+## 	*** cargo install -vv --force is NOT used.
+## 	*** FORCE=--force cargo install -vv $(FORCE) is used.
+## 	*** FORCE=--force cargo install -vv $(FORCE) --path <path>
+## 	*** to overwrite deploy cargo.io crates.
+	export RUSTFLAGS=-Awarning;  for t in $(SUBMODULES); do echo $$t; cargo install --bins --path  $$t -vv $(FORCE) 2>/dev/null || echo ""; done
+	#for t in $(SUBMODULES); do echo $$t; cargo install -vv gnostr-$$t --force || echo ""; done
+
+cargo-build: ### cargo build
+## 	cargo-build q=true
+	@. $(HOME)/.cargo/env
+	@RUST_BACKTRACE=all cargo b $(QUIET)
+cargo-install: ### cargo install --path . $(FORCE)
+	@. $(HOME)/.cargo/env
+	@cargo install --path . $(FORCE)
+## 	cargo-br q=true
+cargo-build-release: ### cargo-build-release
+## 	cargo-build-release q=true
+	@. $(HOME)/.cargo/env
+	@cargo b --release $(QUIET)
+cargo-check: ### cargo-check
+	@. $(HOME)/.cargo/env
+	@cargo c
+cargo-bench: ### cargo-bench
+	@. $(HOME)/.cargo/env
+	@cargo bench
+cargo-test: ### cargo-test
+	@. $(HOME)/.cargo/env
+	#@cargo test
+	cargo test -p gitr #utils::pathing::tests::test_unix_config_path
+cargo-test-nightly: ### cargo-test-nightly
+	@. $(HOME)/.cargo/env
+	#@cargo test
+	cargo +nightly test -p gitr #utils::pathing::tests::test_unix_config_path
+cargo-report: ### cargo-report
+	@. $(HOME)/.cargo/env
+	cargo report future-incompatibilities --id 1
+cargo-run: ### cargo-run
+	@. $(HOME)/.cargo/env
+	cargo run --bin make_to_just
+
+##===============================================================================
+cargo-dist: ### cargo-dist -h
+	cargo dist -h
+cargo-dist-build: ### cargo-dist-build
+	RUSTFLAGS="--cfg tokio_unstable" cargo dist build
+cargo-dist-manifest: ### cargo dist manifest --artifacts=all
+	cargo dist manifest --artifacts=all
+
+# vim: set noexpandtab:
+# vim: set setfiletype make
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..9f9cbb8
--- /dev/null
+++ b/README.md
@@ -0,0 +1,52 @@
+# Detox
+[![Crates.io](https://img.shields.io/crates/v/detox.svg)](https://crates.io/crates/detox)
+[![Build Status](https://img.shields.io/github/workflow/status/whitfin/detox/CI)](https://github.com/whitfin/detox/actions)
+
+Detox is a very small CLI tool used to clean up development directories to
+save disk space. This is particularly handy to use prior to backing up your
+development machine. It was written as a personal tool, but figured it might
+be useful to others.
+
+The main aim is to reduce the amount of space in project directories without
+specifically altering the projects. This pretty much means the basics, such
+as removing target directories, dependency directories, compressing version
+control trees, etc.
+
+The list of structures supported is as below. If you want to add support for
+a new structure, feel free; the initial list is pretty much based on what I
+have on my development machines on a daily basis.
+
+* Cargo (Rust)
+* Git
+* Gradle (Java)
+* Maven (Java)
+* Mix (Elixir)
+* Node.js
+
+If this is the first time you have run this tool, please do read the source
+to validate that it's not going to wipe something important. It should be
+fairly safe given that it only looks at build files etc, but know that you
+are running it at your own risk!
+
+## Installation
+
+Detox is written in Rust, and is available for download via the repository
+on [crates.io](https://crates.io/crates/detox). The easiest way to get this
+at this point is to install it via Cargo:
+
+```shell
+$ cargo install detox
+```
+
+## Usage
+
+The CLI is tiny and instructions are provided via the documentation:
+
+```shell
+$ detox -h
+$ detox <location>
+```
+
+Locations are checked recursively for files which might signal a development
+directory. Various files which are "unnecessary" will then be stripped away,
+and the output will tell you how much space you saved.
diff --git a/build.rs b/build.rs
new file mode 100644
index 0000000..7ece312
--- /dev/null
+++ b/build.rs
@@ -0,0 +1,27 @@
+use std::fs;
+use std::path::Path;
+use std::process::Command;
+
+fn main() {
+    // Re-run this build script if the script changes.
+    println!("cargo:rerun-if-changed=install_script.sh");
+
+    let out_dir = std::env::var("OUT_DIR").unwrap();
+    let dest_path = Path::new(&out_dir).join("install_script.sh");
+
+    // Copy the script to the OUT_DIR.
+    fs::copy("install_script.sh", &dest_path).expect("Failed to copy install_script.sh");
+
+    // Make the copied script executable.
+    if cfg!(target_os = "linux") || cfg!(target_os = "macos") {
+        Command::new("chmod")
+            .arg("+x")
+            .arg(&dest_path)
+            .status()
+            .expect("Failed to make install_script.sh executable");
+    }
+
+    // Tell cargo to include the script in the package.
+    println!("cargo:rustc-env=INSTALL_SCRIPT={}", dest_path.display());
+}
+
diff --git a/install_script.sh b/install_script.sh
new file mode 100755
index 0000000..31e1e69
--- /dev/null
+++ b/install_script.sh
@@ -0,0 +1,146 @@
+#!/bin/bash
+
+# Install cargo-binstall
+curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash && cargo binstall just
+
+# Example: Install a configuration file.
+INSTALL_DIR="$HOME/.my_app"
+CONFIG_FILE="my_config.conf"
+
+mkdir -p "$INSTALL_DIR"
+cp "$1" "$INSTALL_DIR/$CONFIG_FILE" # $1 is the first argument passed to the script, likely the config file itself.
+
+echo "Installed configuration to $INSTALL_DIR/$CONFIG_FILE"
+
+# Example: add a directory to the PATH.
+if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
+  echo 'export PATH="$PATH:$INSTALL_DIR"' >> "$HOME/.bashrc"
+  echo "Added $INSTALL_DIR to PATH. Reload your shell."
+fi
+
+#!/usr/bin/env bash
+
+# Name of the Makefile to be converted
+MAKEFILE="Makefile"
+rm $MAKEFILE 2>/dev/null || true
+touch $MAKEFILE
+
+tee -a $MAKEFILE <<EOF
+help:
+	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?##/ {printf "\033[36m%-15s\033[0m %s\n", $\$1, $\$2}' \$(MAKEFILE_LIST)
+	@echo
+
+##
+##===============================================================================
+##all
+## 	bin
+all: bin### all
+##bin
+## 	cargo b --manifest-path Cargo.toml
+bin:### bin
+	cargo b --manifest-path Cargo.toml
+
+##
+##===============================================================================
+##make cargo-*
+cargo-help:### cargo-help
+	@awk 'BEGIN {FS = ":.*?###"} /^[a-zA-Z_-]+:.*?###/ {printf "\033[36m%-15s\033[0m %s\n", $\$1, $\$2}' \$(MAKEFILE_LIST)
+cargo-release-all:### cargo-release-all
+## 	cargo-release-all recursively cargo build --release
+	for t in */Cargo.toml;  do echo $\$t; cargo b -r -vv --manifest-path $\$t; done
+	for t in ffi/*/Cargo.toml;  do echo $\$t; cargo b -r -vv --manifest-path $\$t; done
+cargo-clean-release:### cargo-clean-release - clean release artifacts
+## 	cargo-clean-release 	recursively cargo clean --release
+	for t in *Cargo.toml;  do echo $\$t && cargo clean --release -vv --manifest-path $\$t 2>/dev/null; done
+cargo-publish-all:### cargo-publish-all
+## 	cargo-publish-all 	recursively publish rust projects
+	for t in *Cargo.toml;  do echo $\$t; cargo publish -vv --manifest-path $\$t; done
+
+cargo-install-bins:###  cargo-install-bins
+## 	cargo-install-all 	recursively cargo install -vv \$(SUBMODULES)
+## 	*** cargo install -vv --force is NOT used.
+## 	*** FORCE=--force cargo install -vv \$(FORCE) is used.
+## 	*** FORCE=--force cargo install -vv \$(FORCE) --path <path>
+## 	*** to overwrite deploy cargo.io crates.
+	export RUSTFLAGS=-Awarning;  for t in \$(SUBMODULES); do echo $\$t; cargo install --bins --path  $\$t -vv \$(FORCE) 2>/dev/null || echo ""; done
+	#for t in \$(SUBMODULES); do echo $\$t; cargo install -vv gnostr-$\$t --force || echo ""; done
+
+cargo-build: ### cargo build
+## 	cargo-build q=true
+	@. \$(HOME)/.cargo/env
+	@RUST_BACKTRACE=all cargo b \$(QUIET)
+cargo-install: ### cargo install --path . \$(FORCE)
+	@. \$(HOME)/.cargo/env
+	@cargo install --path . \$(FORCE)
+## 	cargo-br q=true
+cargo-build-release: ### cargo-build-release
+## 	cargo-build-release q=true
+	@. \$(HOME)/.cargo/env
+	@cargo b --release \$(QUIET)
+cargo-check: ### cargo-check
+	@. \$(HOME)/.cargo/env
+	@cargo c
+cargo-bench: ### cargo-bench
+	@. \$(HOME)/.cargo/env
+	@cargo bench
+cargo-test: ### cargo-test
+	@. \$(HOME)/.cargo/env
+	#@cargo test
+	cargo test -p rust-project-template utils::pathing::tests::test_unix_config_path
+cargo-test-nightly: ### cargo-test-nightly
+	@. \$(HOME)/.cargo/env
+	#@cargo test
+	cargo test --features nightly -p rust-project-template utils::pathing::tests::test_unix_config_path
+cargo-report: ### cargo-report
+	@. \$(HOME)/.cargo/env
+	cargo report future-incompatibilities --id 1
+cargo-run: ### cargo-run
+	@. \$(HOME)/.cargo/env
+	cargo run --bin make_to_just
+
+##===============================================================================
+cargo-dist: ### cargo-dist -h
+	cargo dist -h
+cargo-dist-build: ### cargo-dist-build
+	RUSTFLAGS="--cfg tokio_unstable" cargo dist build
+cargo-dist-manifest: ### cargo dist manifest --artifacts=all
+	cargo dist manifest --artifacts=all
+
+# vim: set noexpandtab:
+# vim: set setfiletype make
+EOF
+
+
+# Name of the output Justfile
+JUSTFILE=".justfile"
+rm $JUSTFILE 2>/dev/null || true
+touch $JUSTFILE
+
+# Check if the Makefile exists
+if [ ! -f "$MAKEFILE" ]; then
+    echo "Makefile not found"
+    exit 1
+fi
+
+# Clear the Justfile content
+> "$JUSTFILE"
+
+# Add in the default recipe to Justfile
+echo "default:" >> "$JUSTFILE"
+echo -e "  just --choose\n" >> "$JUSTFILE"
+
+# Read each line in the Makefile
+while IFS= read -r line
+do
+    # Extract target names (lines ending with ':')
+    if [[ "$line" =~ ^[a-zA-Z0-9_-]+: ]]; then
+        # Extract the target name
+        target_name=$(echo "$line" | cut -d':' -f1)
+
+        # Write the corresponding recipe to Justfile
+        echo "$target_name:" >> "$JUSTFILE"
+        echo -e "  @make $target_name\n" >> "$JUSTFILE"
+    fi
+done < "$MAKEFILE"
+
+echo "Successfully ported the Makefile to Justfile."
diff --git a/src/bin/git-tree.rs b/src/bin/git-tree.rs
new file mode 100644
index 0000000..e3bb80e
--- /dev/null
+++ b/src/bin/git-tree.rs
@@ -0,0 +1,57 @@
+#![allow(unused_imports)] // For potential future imports
+
+use std::fs;
+use std::path::{Path, PathBuf};
+
+#[derive(Debug)]
+struct Node {
+    folder: String,
+    files: Vec<String>,
+    children: Vec<Box<Node>>,
+}
+
+fn build_git_tree(path: &Path) -> Result<Option<Box<Node>>, std::io::Error> {
+    if !path.is_dir() {
+        return Ok(None);
+    }
+
+    let folder_name = path
+        .file_name()
+        .and_then(|s| s.to_str())
+        .map(|s| s.to_string())
+        .unwrap_or_else(|| String::from(""));
+
+    let mut files = Vec::new();
+    let mut children = Vec::new();
+
+    for entry in fs::read_dir(path)? {
+        let entry = entry?;
+        let entry_path = entry.path();
+
+        if entry_path.is_file() {
+            if let Some(file_name) = entry_path.file_name().and_then(|s| s.to_str()) {
+                files.push(file_name.to_string());
+            }
+        } else if entry_path.is_dir() {
+            if let Some(child_node) = build_git_tree(&entry_path)? {
+                children.push(child_node);
+            }
+        }
+    }
+
+    Ok(Some(Box::new(Node {
+        folder: folder_name,
+        files,
+        children,
+    })))
+}
+
+fn main() -> Result<(), std::io::Error> {
+    let git_path = Path::new(".git"); // Replace with your .git directory path
+    if let Some(root_node) = build_git_tree(git_path)? {
+        println!("{:#?}", root_node);
+    } else {
+        println!(".git not found or empty.");
+    }
+    Ok(())
+}
diff --git a/src/cleaner.rs b/src/cleaner.rs
new file mode 100644
index 0000000..6a04cab
--- /dev/null
+++ b/src/cleaner.rs
@@ -0,0 +1,135 @@
+//! Cleaning traits and implementations.
+mod cargo;
+mod git;
+mod gnostr;
+mod gradle;
+mod macos;
+mod makefile;
+mod maven;
+mod mix;
+mod node;
+mod rustup;
+
+pub use cargo::CargoCleaner;
+pub use git::GitCleaner;
+pub use gnostr::GnostrCleaner;
+pub use gradle::GradleCleaner;
+pub use macos::MacosCleaner;
+pub use makefile::MakeFileCleaner;
+pub use maven::MavenCleaner;
+pub use mix::MixCleaner;
+pub use node::NodeCleaner;
+pub use rustup::RustupCleaner;
+
+use std::env;
+use std::fs;
+use std::io::{self, ErrorKind};
+use std::process::{Command, Stdio};
+use std::str;
+
+/// Trait to represent a cleaning structure.
+pub trait Cleaner {
+    /// Returns the name of the current cleaner.
+    fn name(&self) -> &str;
+
+    /// Cleans a directory assumed to be a relevant directory.
+    fn clean(&self, dir: &str) -> io::Result<()>;
+
+    /// Returns a set of file names which identify a relevant directory.
+    fn triggers(&self) -> &[&str];
+}
+
+fn is_program_in_path(program: &str) -> bool {
+    if let Ok(path) = env::var("PATH") {
+        for p in path.split(":") {
+            let p_str = format!("{}/{}", p, program);
+            if fs::metadata(&p_str).is_ok() {
+                println!("Trying: {}", p_str);
+                return true;
+            }
+        }
+    }
+    false
+}
+
+/// Executes a command in a directory using provided arguments.
+pub fn cmd(dir: &str, cmd: &str, args: &[&str]) -> io::Result<()> {
+    let is_command = is_program_in_path(cmd);
+    if !is_command {
+        let cmd = &"ls";
+        let cmd_output = Command::new(cmd)
+            .current_dir(dir)
+            .stdout(Stdio::piped())
+            .stderr(Stdio::null())
+            .spawn()?
+            .wait_with_output()?;
+        if !cmd_output.status.success() {
+            println!("Command failed with status: {}", cmd_output.status);
+        }
+        let cmd_stdout = str::from_utf8(&cmd_output.stdout).expect("");
+        println!("ls Stdout: {}", cmd_stdout);
+    } else {
+        let cmd_output = Command::new(cmd)
+            .args(args)
+            .current_dir(dir)
+            .stdout(Stdio::piped())
+            .stderr(Stdio::null())
+            .spawn()?
+            .wait_with_output()?;
+        if !cmd_output.status.success() {
+            println!("Command failed with status: {}", cmd_output.status);
+        }
+        let cmd_stdout = str::from_utf8(&cmd_output.stdout).expect("");
+        println!("Cmd Stdout: {}", cmd_stdout);
+    }
+    Ok(())
+}
+
+/// Purges a location on disk, similar to `rm -rf`.
+pub fn del(parent: &str, child: &str) -> io::Result<()> {
+    let dir_path = format!("{}/{}", parent, child);
+    println!("{}", dir_path);
+
+    // check for errors that we're ok with
+    if let Err(err) = fs::remove_dir_all(dir_path) {
+        // if already gone, happy days are upon us
+        if err.kind() == ErrorKind::NotFound {
+            return Ok(());
+        }
+        // if there's a permission error, we don't care
+        if err.kind() == ErrorKind::PermissionDenied {
+            return Ok(());
+        }
+        if err.kind() == ErrorKind::Other {
+            let file_path = format!("{}/{}", parent, child);
+            println!("{}", file_path);
+            // check for errors that we're ok with
+            if let Err(err) = fs::remove_file(file_path) {
+                // if already gone, happy days are upon us
+                if err.kind() == ErrorKind::NotFound {
+                    return Ok(());
+                }
+
+                // if there's a permission error, we don't care
+                if err.kind() == ErrorKind::PermissionDenied {
+                    return Ok(());
+                }
+                if err.kind() == ErrorKind::Other {
+                    return Ok(());
+                }
+
+                // others, bad!
+                // return Err(err);
+                println!("{:?}", Some(err));
+            }
+
+            return Ok(());
+        }
+
+        // others, bad!
+        // return Err(err);
+        println!("{:?}", Some(err));
+    }
+
+    Ok(())
+}
diff --git a/src/cleaner/cargo.rs b/src/cleaner/cargo.rs
new file mode 100644
index 0000000..a5d1f38
--- /dev/null
+++ b/src/cleaner/cargo.rs
@@ -0,0 +1,25 @@
+//! Basic cleaner module for Cargo projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Cargo projects.
+pub struct CargoCleaner;
+impl Cleaner for CargoCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Cargo"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &["Cargo.toml", "vendor", ".cargo"]
+    }
+
+    /// cleaner the provided directory based on a Cargo structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "cargo", &["clean"])?;
+        super::del(dir, "target")?;
+        super::del(dir, "vendor") //?;
+                                  //super::del(dir, ".cargo/registry")
+    }
+}
diff --git a/src/cleaner/git.rs b/src/cleaner/git.rs
new file mode 100644
index 0000000..c259eeb
--- /dev/null
+++ b/src/cleaner/git.rs
@@ -0,0 +1,24 @@
+//! Basic cleaner module for Git projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Git projects.
+pub struct GitCleaner;
+impl Cleaner for GitCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Git"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &[".git", ".libs"]
+    }
+
+    /// Cleans the provided directory based on a Git structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        let _ = super::cmd(dir, "git", &["status"])?;
+        let _ = super::cmd(dir, "git", &["reflog", "expire", "--all", "--expire=now"])?;
+        super::cmd(dir, "git", &["gc", "--prune=now", "--aggressive"])
+    }
+}
diff --git a/src/cleaner/gnostr.rs b/src/cleaner/gnostr.rs
new file mode 100644
index 0000000..37f0f23
--- /dev/null
+++ b/src/cleaner/gnostr.rs
@@ -0,0 +1,23 @@
+//! Basic cleaner module for Cargo projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Gnostr Artifacts
+pub struct GnostrCleaner;
+impl Cleaner for GnostrCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Gnostr"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &[".gnostr"]
+    }
+
+    /// cleaner the provided directory based on a Cargo structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "cargo", &["clean"])?;
+        super::del(dir, "node_modules")
+    }
+}
diff --git a/src/cleaner/gradle.rs b/src/cleaner/gradle.rs
new file mode 100644
index 0000000..355b01e
--- /dev/null
+++ b/src/cleaner/gradle.rs
@@ -0,0 +1,24 @@
+//! Basic cleaner module for Gradle projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Gradle projects.
+pub struct GradleCleaner;
+impl Cleaner for GradleCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Gradle"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &["build.gradle"]
+    }
+
+    /// Cleans the provided directory based on a Git structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "gradle", &["clean"])?;
+        super::del(dir, "build")?;
+        super::del(dir, "out")
+    }
+}
diff --git a/src/cleaner/macos.rs b/src/cleaner/macos.rs
new file mode 100644
index 0000000..b89db47
--- /dev/null
+++ b/src/cleaner/macos.rs
@@ -0,0 +1,38 @@
+//! Basic cleaner module for Node.js projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Node.js projects.
+pub struct MacosCleaner;
+impl Cleaner for MacosCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Macos"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &[
+            ".DS_Store",
+            ".Trash",
+            "MailData/Downloads",
+            "Library/Logs",
+            "Library/Developer/Xcode/Archives",
+            "Library/Developer/Xcode/DerivedData",
+            "Library/Developer/CoreSimulator/Devices",
+            "Library/Caches/org.swift.swiftpm",
+            "Library/Caches/Homebrew",
+            "Developer/CoreSimulator/Caches",
+        ]
+    }
+
+    /// Cleans the provided directory based on a certain criteria.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        let _ = super::cmd(dir, "brew", &["cleanup"])?;
+        let _ = super::cmd(dir, "brew", &["autoremove"])?;
+        let _ = super::cmd(dir, "rm", &[".DS_Store"])?;
+        let _ = super::cmd(dir, "rm", &["-rf", ".Trash"])?;
+
+        super::del(dir, ".DS_Store")
+    }
+}
diff --git a/src/cleaner/makefile.rs b/src/cleaner/makefile.rs
new file mode 100644
index 0000000..7ef3c45
--- /dev/null
+++ b/src/cleaner/makefile.rs
@@ -0,0 +1,34 @@
+//! Basic cleaner module for Git projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Git projects.
+pub struct MakeFileCleaner;
+impl Cleaner for MakeFileCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "MakeFile"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &[
+            "Makefile",
+            "GNUmakefile",
+            "CMakeFiles",
+            "CMakeCache",
+            ".deps",
+            ".libs",
+        ]
+    }
+
+    /// Cleans the provided directory based on a Git structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "make", &["clean"])?;
+        super::cmd(dir, "rm", &["-rf", "CmakeFiles"])?;
+        super::cmd(dir, "rm", &["-rf", "build"])?;
+        super::cmd(dir, "rm", &["-rf", ".deps"])?;
+        super::cmd(dir, "rm", &["-rf", ".libs"])?;
+        super::cmd(dir, "rm", &["-rf", "CmakeCache"])
+    }
+}
diff --git a/src/cleaner/maven.rs b/src/cleaner/maven.rs
new file mode 100644
index 0000000..2815e12
--- /dev/null
+++ b/src/cleaner/maven.rs
@@ -0,0 +1,23 @@
+//! Basic cleaner module for Maven projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Maven projects.
+pub struct MavenCleaner;
+impl Cleaner for MavenCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Maven"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &["pom.xml"]
+    }
+
+    /// Cleans the provided directory based on a Git structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "mvn", &["clean"])?;
+        super::del(dir, "target")
+    }
+}
diff --git a/src/cleaner/mix.rs b/src/cleaner/mix.rs
new file mode 100644
index 0000000..1ecd446
--- /dev/null
+++ b/src/cleaner/mix.rs
@@ -0,0 +1,25 @@
+//! Basic cleaner module for Mix projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Mix projects.
+pub struct MixCleaner;
+impl Cleaner for MixCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Mix"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &["mix.exs"]
+    }
+
+    /// Cleans the provided directory based on a Git structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::cmd(dir, "mix", &["clean"])?;
+        super::del(dir, "build")?;
+        super::del(dir, "deps")?;
+        super::del(dir, "doc")
+    }
+}
diff --git a/src/cleaner/node.rs b/src/cleaner/node.rs
new file mode 100644
index 0000000..9033301
--- /dev/null
+++ b/src/cleaner/node.rs
@@ -0,0 +1,23 @@
+//! Basic cleaner module for Node.js projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for Node.js projects.
+pub struct NodeCleaner;
+impl Cleaner for NodeCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Node.js"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &["package.json", "yarn.json", ".npm"]
+    }
+
+    /// Cleans the provided directory based on a NodeJS structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        super::del(dir, "node_modules")?;
+        super::del(dir, ".npm")
+    }
+}
diff --git a/src/cleaner/rustup.rs b/src/cleaner/rustup.rs
new file mode 100644
index 0000000..3134017
--- /dev/null
+++ b/src/cleaner/rustup.rs
@@ -0,0 +1,23 @@
+//! Basic cleaner module for Cargo projects.
+use super::Cleaner;
+use std::io;
+
+/// Cleaner implementation for rustup
+pub struct RustupCleaner;
+impl Cleaner for RustupCleaner {
+    /// Returns the name of this cleaner.
+    fn name(&self) -> &str {
+        "Rustup"
+    }
+
+    /// Returns the triggers associated with this cleaner.
+    fn triggers(&self) -> &[&str] {
+        &[".rustup"]
+    }
+
+    /// cleaner the provided directory based on a Cargo structure.
+    fn clean(&self, dir: &str) -> io::Result<()> {
+        let _ = super::del(dir, ".rustup");
+        super::cmd(dir, "rustup", &["default", "stable"])
+    }
+}
diff --git a/src/git_service.rs b/src/git_service.rs
new file mode 100644
index 0000000..7000926
--- /dev/null
+++ b/src/git_service.rs
@@ -0,0 +1,438 @@
+#![warn(deprecated)]
+extern crate chrono;
+extern crate git2;
+use crate::*;
+use chrono::{DateTime, FixedOffset, TimeZone, Utc};
+use clap::Parser;
+use git2::BranchType;
+use git2::{Error, Repository};
+use std::collections::HashSet;
+use std::fs;
+use std::io::BufRead;
+use std::io::BufReader;
+use std::process;
+
+pub fn start_git() {
+    let args = Config::parse();
+    let _excluded_commits: Vec<git2::Oid> = vec![];
+    let repo = match load_repository(&args.repo.unwrap()) {
+        Ok(repo) => repo,
+        Err(e) => {
+            eprintln!("Fail to open the repository {}", e);
+            process::exit(0);
+        }
+    };
+    match (
+        &args.commit,
+        &args.commits,
+        &args.commits_file,
+        &args.commit_since,
+        &args.commit_until,
+        &args.commit_from,
+        &args.commit_to,
+        args.uncommitted,
+    ) {
+        (Some(commit), _, _, _, _, _, _, _) => {
+            if let Err(e) = handle_single_commit(repo, commit) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, Some(commits), _, _, _, _, _, _) => {
+            let commit_ids: Vec<&str> = commits.split(',').collect();
+            if let Err(e) = handle_multiple_commits(repo, &commit_ids) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, _, Some(file_path), _, _, _, _, _) => {
+            if let Err(e) = handle_commits_file(repo, file_path) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, _, _, Some(since), Some(until), _, _, _) => {
+            if let Err(e) = handle_commit_range_by_time(repo, since, until) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, _, _, _, _, Some(commit_from), Some(commit_to), _) => {
+            if let Err(e) = handle_commit_range(repo, Some(commit_from.clone()), Some(commit_to.clone())) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, _, _, _, _, _, _, true) => {
+            if let Err(e) = handle_uncommitted_files(repo) {
+                eprintln!("Application error: {}", e);
+                process::exit(0);
+            }
+        }
+        (_, _, _, _, _, _, _, false) => {
+            // 处理未提供未提交选项的情况
+        }
+    }
+    
+    // match (&args.commit, &args.commits, &args.commits_file, &args.commit_since, &args.commit_until, &args.commit_from, &args.commit_to) {
+    //     (Some(commit), None, None, None, None, None, None) => {
+
+    //         if let Err(e) = handle_single_commit(repo, commit) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     (None, Some(commits), None, None, None, None, None) => {
+    //         let commit_ids: Vec<&str> = commits.split(',').collect();
+    //         if let Err(e) = handle_multiple_commits(repo, &commit_ids) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     (None, None, Some(file_path), None, None, None, None) => {
+    //         if let Err(e) = handle_commits_file(repo, &file_path) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     (None, None, None, Some(since), Some(until), None, None) => {
+    //         if let Err(e) = handle_commit_range_by_time(repo, since, until) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     (None, None, None, None, None, Some(commit_from), Some(commit_to)) => {
+    //         if let Err(e) = handle_commit_range(repo, Some(commit_from.clone()), Some(commit_to.clone())){
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     _ => {
+    //         // Handle the case where no relevant arguments are provided
+    //     }
+    // }
+    
+    
+
+    // // // 扫描一个commit的内容
+    // match &args.commit {
+    //     Some(commit) => {
+    //         if let Err(e) = handle_single_commit(repo, commit) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     None => {
+            
+    //     }
+    // }
+    // // // 扫描多个commit
+    // match &args.commits {
+    //     Some(commits) => {
+    //         let commit_ids: Vec<&str> = commits.split(',').collect();
+    //         if let Err(e) = handle_multiple_commits(repo, &commit_ids) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     None => {
+
+    //     }
+    // }
+    // // 扫描commit file
+    // match &args.commits_file {
+    //     Some(file_path) => {
+    //         if let Err(e) = handle_commits_file(repo, &file_path) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     None => {
+    //     }
+    // }
+
+    // match (&args.commit_since, &args.commit_until) {
+    //     (Some(since), Some(until)) => {
+    //         if let Err(e) = handle_commit_range_by_time(repo, since,until) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     _ => {
+
+    //     }
+    // }
+
+    // match (&args.commit_from, &args.commit_to) {
+    //     (Some(commit_from), Some(commit_to)) => {
+    //         if let Err(e) = handle_commit_range(repo, Some(commit_from.clone()), Some(commit_to.clone())){
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+            
+    //     }
+    //     _ => {
+    //     }
+    // }
+    // ////////////////////////////////////////////////////////////////
+    //  match (&args.commit_since, &args.commit_until) {
+    //     (Some(since), Some(until)) => {
+    //         if let Err(e) = handle_commit_range_by_time(repo, since,until) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     _ => {
+
+    //     }
+    // }
+    // match args.uncommitted {
+    //     true => {
+    //         if let Err(e) = handle_uncommitted_files(repo) {
+    //             eprintln!("Application error: {}", e);
+    //             process::exit(0);
+    //         }
+    //     }
+    //     false => {
+    //         // 处理未提供未提交选项的情况
+    //     }
+    // }
+    
+
+}
+// 扫描一个commit的内容
+pub fn handle_single_commit(repo: Repository, commit_id: &str) -> Result<(), git2::Error> {
+    let commit = repo.find_commit(git2::Oid::from_str(commit_id)?)?;
+    let commit_info = config_commit_info(&repo, &commit)?;
+
+    let commits_list = vec![commit_info];
+
+    
+    handle_commit_info(&commits_list);
+    Ok(())
+}
+// 扫描多个commit的内容
+pub fn handle_multiple_commits(repo: Repository, commit_ids: &[&str]) -> Result<(), git2::Error> {
+    let mut commits_list=vec![];
+   
+    for commit_id in commit_ids {
+        let commit = repo.find_commit(git2::Oid::from_str(commit_id)?)?;
+        let commit_info = config_commit_info(&repo, &commit)?;
+        commits_list.push(commit_info);
+    }
+   
+    handle_commit_info(&commits_list);
+    Ok(())
+}
+// 扫描commit文件
+pub fn handle_commits_file(repo: Repository, file_name: &str)-> Result<(), git2::Error> {
+    let file = fs::File::open(file_name).expect("Failed to open commits file");
+    let reader = BufReader::new(file);
+    let mut commits: Vec<String> = Vec::new();
+
+    for line in reader.lines().flatten() {
+        commits.push(line);
+    }
+    
+    let commit_ids: Vec<&str> = commits.iter().map(|s| s.as_str()).collect();
+
+    handle_multiple_commits(repo, &commit_ids)
+}
+// 扫描commit，根据时间
+fn handle_commit_range_by_time(repo: Repository, since: &str, until: &str) -> Result<(), git2::Error>{
+    //TODO
+    let excluded_commits: Vec<git2::Oid> = vec![];
+    let is_since_rfc3339 = DateTime::parse_from_rfc3339(since).is_ok();
+    let is_until_rfc3339 = DateTime::parse_from_rfc3339(until).is_ok();
+    
+    let is_since_date = is_valid_date_format(since);
+    let is_until_date = is_valid_date_format(until);
+
+    if is_since_date && is_until_date {
+        let start_time = match parse_start_date_to_datetime(since, "start") {
+            Ok(datetime) => datetime.with_timezone(&FixedOffset::east(0)),
+            Err(err) => {
+                eprintln!("时间格式错误 error: {}", err);
+                process::exit(0);
+            }
+        };
+
+        let end_time = match parse_start_date_to_datetime(until, "until") {
+            Ok(datetime) => datetime.with_timezone(&FixedOffset::east(0)),
+            Err(err) => {
+                eprintln!("时间格式错误 error: {}", err);
+                process::exit(0);
+            }
+        };
+
+        // 调用处理函数并传递日期参数
+         handle_multiple_commits_by_time(&repo, &excluded_commits, start_time, end_time)
+         
+        // 处理两者都是 %Y-%m-%d 格式的情况
+    } else if is_since_rfc3339 && is_until_rfc3339 {
+        // 处理两者都是 RFC 3339 格式的情况
+        let start_time = DateTime::parse_from_rfc3339(since).unwrap();
+        let end_time = DateTime::parse_from_rfc3339(until).unwrap();
+
+        // 调用处理函数并传递日期参数
+        handle_multiple_commits_by_time(&repo, &excluded_commits, start_time, end_time)
+        
+    } else {
+        eprintln!("Application error: 格式不正确");
+        process::exit(0);
+        // 处理其他情况
+    }
+}
+
+pub fn handle_multiple_commits_by_time(
+    repo: &Repository,
+    excluded_commits: &[git2::Oid],
+    start_time: DateTime<FixedOffset>,
+    end_time: DateTime<FixedOffset>,
+) -> Result<(), git2::Error> {
+    let head = repo.head()?;
+    let obj = head.peel(git2::ObjectType::Commit)?;
+    let commit = if let Some(commit) = obj.as_commit() {
+        commit.clone()
+    } else {
+        return Err(Error::from_str("Failed to convert object to commit"));
+    };
+
+    let mut revwalk = repo.revwalk()?;
+    revwalk.push(commit.id())?;
+    revwalk.set_sorting(git2::Sort::TOPOLOGICAL)?;
+
+    let mut commits = Vec::new();
+
+    let excluded_commits: HashSet<_> = excluded_commits.iter().cloned().collect();
+
+    for commit_id in revwalk {
+        let oid = commit_id?;
+        if excluded_commits.contains(&oid) {
+            continue; // Skip excluded commits
+        }
+        let commit = repo.find_commit(oid)?;
+        let commit_time = Utc.timestamp(commit.time().seconds(), 0);
+        let commit_offset = FixedOffset::west(commit.time().offset_minutes() * 60);
+        let commit_date = commit_offset.from_utc_datetime(&commit_time.naive_utc());
+
+        if commit_date >= start_time && commit_date <= end_time {
+            let commit_info = config_commit_info(repo, &commit)?;
+            commits.push(commit_info);
+        }
+    }
+    handle_commit_info(&commits);
+    Ok(())
+}
+
+pub fn handle_branches_by_name(
+    repo: Repository,
+    branch_name: &str,
+) -> Result<(), Error> {
+    let branches = repo.branches(Some(BranchType::Local))?;
+
+    let mut commits = Vec::new();
+    // let mut commits_ids = Vec::new();
+
+    for branch in branches {
+        let (branch, _) = branch?;
+        let branch_reference = branch.into_reference();
+        let branch_name_str = branch_reference.name().unwrap_or("");
+
+        if branch_name_str.contains(branch_name) {
+            let commit_oid = branch_reference
+                .target()
+                .ok_or_else(|| Error::from_str("Failed to get branch commit"))?;
+            let commit = repo.find_commit(commit_oid)?;
+            let commit_info = config_commit_info(&repo, &commit)?;
+            commits.push(commit_info);
+            // commits_ids.push(commit_oid.to_string());
+        }
+    }
+    handle_commit_info(&commits);
+    Ok(())
+    // Ok(commits)
+}
+
+pub fn handle_commit_info(commit_info_list: &[CommitInfo]) {
+    println!("Total Commits: {}", commit_info_list.len());
+    println!("Commit history:");
+    for commit_info in commit_info_list {
+        println!("repo: {}", commit_info.repo);
+        println!("commit: {}", commit_info.commit);
+        println!("author: {}", commit_info.author);
+        println!("email: {}", commit_info.email);
+        println!("commitMessage: {}", commit_info.commit_message);
+        println!("tags: {:?}", commit_info.tags.to_owned());
+        println!("Operation: {}", commit_info.operation);
+        println!("date: {}", commit_info.date.format("%Y-%m-%dT%H:%M:%S%z"));
+        println!("Files:");
+        for (file, _content) in &commit_info.files {
+            println!("File: {}", file);
+            // println!("Content:\n{}", content);
+            println!("----------------------");
+            }
+            println!("======================");
+        }
+}
+pub fn handle_commit_range(repo: Repository, commit_from: Option<String>, commit_to: Option<String>) -> Result<(), git2::Error> {
+    let all_commits = {
+        let repo_ref = &repo;
+        match load_all_commits(repo_ref) {
+            Ok(all_commits) => all_commits,
+            Err(e) => {
+                eprintln!("获取提交列表失败：{}", e);
+                return Ok(());
+            }
+        }
+    };
+
+    let results = load_commits_by_conditions(commit_from, commit_to, &all_commits);
+    let commit_ids: Vec<&str> = results.iter().map(|s| s.as_str()).collect();
+    handle_multiple_commits(repo, &commit_ids)
+}
+fn handle_uncommitted_files(repo: Repository)-> Result<(), git2::Error> {
+
+    let statuses = repo.statuses(None).unwrap();
+
+    let mut uncommitted_files = Vec::new();
+
+    for entry in statuses.iter() {
+        if entry.status().is_index_modified() || entry.status().is_wt_modified() {
+            if let Some(path) = entry.path() {
+                uncommitted_files.push(path.to_owned());
+            }
+        }
+    }
+
+    // println!("Uncommitted files:P{:?}",uncommitted_files);
+    for file in uncommitted_files {
+        println!("{:?}", file);
+    }
+    // 获取仓库状态
+    // let mut options = StatusOptions::new();
+    // options.include_untracked(true);
+
+    // let statuses = repo.statuses(Some(&mut options)).expect("Failed to get statuses");
+
+    // // 遍历未提交的文件
+    // for entry in statuses.iter() {
+       
+    //     let status = entry.status();
+    //     println!("111111");
+    //     if status.is_wt_new() || status.is_wt_modified() {
+    //         println!("2222");
+    //         let path = entry.path().expect("Failed to get path");
+    //         println!("Uncommitted file: {}", path);
+
+    //         // 读取文件内容
+    //         let mut file = File::open(path).expect("Failed to open file");
+    //         let mut contents = String::new();
+    //         file.read_to_string(&mut contents).expect("Failed to read file");
+
+    //         println!("File content:\n{}", contents);
+
+    //     }
+    // }
+    Ok(())
+}
diff --git a/src/git_util.rs b/src/git_util.rs
new file mode 100644
index 0000000..12909b7
--- /dev/null
+++ b/src/git_util.rs
@@ -0,0 +1,220 @@
+#![warn(unused_assignments)]
+extern crate chrono;
+extern crate git2;
+use crate::*;
+use chrono::{DateTime, FixedOffset, TimeZone, Utc};
+use git2::{Error, Repository};
+
+use chrono::{NaiveDate, NaiveDateTime, NaiveTime};
+
+pub fn config_repo_name(repo: &Repository) -> Result<String, Error> {
+    let repo_path = repo.path();
+    let repo_dir = repo_path
+        .parent()
+        .ok_or_else(|| Error::from_str("Invalid repository path"))?;
+    let repo_name = repo_dir
+        .file_name()
+        .and_then(|s| s.to_str())
+        .unwrap_or("")
+        .to_string();
+    if repo_name.ends_with(".git") {
+        Ok(repo_name[..repo_name.len() - 4].to_string())
+    } else {
+        Ok(repo_name)
+    }
+}
+
+pub fn traverse_tree(
+    repo: &Repository,
+    tree: &git2::Tree,
+    path: &str,
+    files: &mut Vec<(String, String)>,
+) -> Result<(), Error> {
+    for entry in tree.iter() {
+        let entry_path = format!("{}/{}", path, entry.name().unwrap());
+        if entry.kind() == Some(git2::ObjectType::Blob) {
+            let blob = repo.find_blob(entry.id())?;
+            let content = String::from_utf8_lossy(blob.content());
+            files.push((entry_path, content.to_string()));
+        } else if entry.kind() == Some(git2::ObjectType::Tree) {
+            let subtree = repo.find_tree(entry.id())?;
+            traverse_tree(repo, &subtree, &entry_path, files)?;
+        }
+    }
+    Ok(())
+}
+pub fn config_commit_info(repo: &Repository, commit: &git2::Commit) -> Result<CommitInfo, Error> {
+    let commit_id = commit.id();
+    let author = commit.author();
+    let email = author.email().unwrap_or("").to_string();
+    let commit_message = commit.message().unwrap_or("").to_string();
+    let date = Utc.timestamp(commit.time().seconds(), 0);
+    let offset = FixedOffset::west(commit.time().offset_minutes() * 60);
+    let mut files = Vec::new();
+    let repo_name = config_repo_name(repo)?;
+    let tags = vec![];
+    //todo
+    let operation ="addition".to_owned();
+    // Retrieve the tree of the commit
+    let tree = commit.tree()?;
+    // Traverse the tree to get the file paths and content
+    traverse_tree(repo, &tree, "", &mut files)?;
+
+    let commit_info = CommitInfo {
+        repo: repo_name,
+        commit: commit_id,
+        author: author.name().unwrap_or("").to_string(),
+        email,
+        commit_message,
+        date: offset.from_utc_datetime(&date.naive_utc()),
+        files,
+        tags,
+        operation,
+    };
+
+    Ok(commit_info)
+}
+
+pub fn load_all_commits(repo: &Repository) -> Result<Vec<String>, git2::Error> {
+ 
+    let mut revwalk = repo.revwalk()?;
+    
+    revwalk.push_head()?;
+    revwalk.set_sorting(git2::Sort::TOPOLOGICAL)?;
+    
+    let mut commits = Vec::new();
+    
+    for oid in revwalk {
+        let oid = oid?;
+        let commit = repo.find_commit(oid)?;
+        let commit_id = commit.id().to_string();
+        commits.push(commit_id);
+    }
+    
+    Ok(commits)
+}
+
+pub fn load_commits_by_conditions(commit_from: Option<String>, commit_to: Option<String>, commits: &[String]) -> Vec<String> {
+    match (commit_from, commit_to) {
+        (Some(start_commit), Some(end_commit)) => {
+            let start_index = commits.iter().position(|commit| *commit == start_commit);
+            let end_index = commits.iter().position(|commit| *commit == end_commit);
+
+            if let (Some(start), Some(end)) = (start_index, end_index) {
+                if start <= end {
+                    commits[start..=end].to_vec()
+                } else {
+                    Vec::new() // Return an empty vector if start_commit is after end_commit
+                }
+            } else {
+                Vec::new() // Return an empty vector if either commit is not found
+            }
+        }
+        _ => Vec::new(), // Return an empty vector if either commit_from or commit_to is None
+    }
+}
+
+pub fn load_repository(repo_path: &str) -> Result<Repository, Box<dyn std::error::Error>> {
+    let repo = match Repository::open(repo_path) {
+        Ok(repo) => {
+            println!("Successfullt open {}", repo.path().display());
+            repo
+        }
+        Err(e) => {
+            eprintln!("Fail to load repo{}", e);
+            return Err(Box::new(e));
+        }
+    };
+
+    Ok(repo)
+}
+
+pub fn config_printed_repo_info(repo: &Repository) {
+    // Get all object IDs in the repository
+    let object_ids = load_all_object_ids(repo).unwrap();
+
+    // Initialize counters for different object types
+    let mut total_count = 0;
+    let mut delta_count = 0;
+    let mut reused_count = 0;
+
+    // Iterate over each object ID
+    for object_id in object_ids {
+        // Find the Git object using its ID
+        let object = repo.find_object(object_id, None).unwrap();
+
+        // Increment the total count
+        total_count += 1;
+
+        // Check if the object is of type Commit
+        if object.kind() == Some(git2::ObjectType::Commit) {
+            // Increment the delta count
+            delta_count += 1;
+        }
+    }
+
+    // Calculate the reused count (assuming you have the logic for it)
+    reused_count = total_count - delta_count;
+
+    // Print the information
+    println!("Enumerating objects: {} done.", total_count);
+    println!(
+        "Total {} (delta {}), reused {} , pack-reused 0",
+        total_count, delta_count, reused_count
+    );
+}
+
+pub fn load_all_object_ids(repo: &Repository) -> Result<Vec<git2::Oid>, git2::Error> {
+    let mut object_ids = Vec::new();
+    let odb = repo.odb()?;
+
+    odb.foreach(|id| {
+        object_ids.push(*id);
+        true
+    })?;
+
+    Ok(object_ids)
+}
+
+pub fn parse_start_date_to_datetime(input: &str, mytype: &str) -> Result<DateTime<Utc>, &'static str> {
+    let date = NaiveDate::parse_from_str(input, "%Y-%m-%d").map_err(|_| "Invalid date format")?;
+    let time: NaiveTime;
+    if mytype == "start" {
+        if let Some(t) = NaiveTime::from_hms_opt(0, 0, 0) {
+            time = t;
+        } else {
+            return Err("Invalid time format");
+        }
+    } else  if let Some(t) = NaiveTime::from_hms_opt(23, 59, 59) {
+                time = t;
+    } else {
+           return Err("Invalid time format");
+    }
+        
+    let datetime = NaiveDateTime::new(date, time);
+    let datetime_utc = DateTime::from_utc(datetime, Utc);
+    Ok(datetime_utc)
+}
+pub fn is_valid_date_format(input: &str) -> bool {
+    if let Ok(date) = NaiveDate::parse_from_str(input, "%Y-%m-%d") {
+        // 日期解析成功
+        let formatted = date.format("%Y-%m-%d").to_string();
+        return formatted == input;
+    }
+    false
+}
+
+pub fn load_commit_tags(repo: &Repository, commit_id: git2::Oid) -> Result<Vec<String>, Error> {
+    let tags = repo.tag_names(None)?;
+    let mut commit_tags = Vec::new();
+
+    for tag_name in tags.iter().flatten() {
+        let target_id = repo.revparse_single(tag_name)?.peel_to_commit()?.id();
+        if target_id == commit_id {
+            commit_tags.push(tag_name.to_string());
+        }
+    }
+    
+
+    Ok(commit_tags)
+}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
new file mode 100644
index 0000000..2f81bba
--- /dev/null
+++ b/src/lib.rs
@@ -0,0 +1,7 @@
+
+mod models;
+mod git_service;
+mod git_util;
+pub use models::*;
+pub use  git_service::*;
+pub use git_util::*;
\ No newline at end of file
diff --git a/src/main.rs b/src/main.rs
new file mode 100644
index 0000000..be4b46f
--- /dev/null
+++ b/src/main.rs
@@ -0,0 +1,6 @@
+use gitr::*;
+
+
+fn main() {
+    start_git();
+}
diff --git a/src/models.rs b/src/models.rs
new file mode 100644
index 0000000..59a7eb5
--- /dev/null
+++ b/src/models.rs
@@ -0,0 +1,206 @@
+#![warn(clippy::new_without_default)]
+use clap::Parser;
+use serde::{Deserialize, Serialize};
+use chrono::{DateTime, FixedOffset};
+/// Represents the configuration for sensleaks tool.
+#[derive(Parser, Debug)]
+#[command(
+    author = "Chen Yijun",
+    version = "0.1.1",
+    about = "sensleaks-rs",
+    long_about = "sensleaks: A tool to detect sensitive information in Git repository",
+    after_help = "Repository: https://github.com/open-rust-initiative/sensleak-rs"
+)]
+pub struct Config {
+    /// Target repository.
+    #[arg(short, long, default_value = ".")]
+    pub repo: Option<String>,
+
+    /// sha of commit to scan or "latest" to scan the last commit of the repository
+    #[arg(long)]
+    pub commit: Option<String>,
+
+    /// comma separated list of a commits to scan
+    #[arg(long)]
+    pub commits: Option<String>,
+
+    /// file of new line separated list of a commits to scan
+    #[arg(long)]
+    pub commits_file: Option<String>,
+
+    /// Scan commits more recent than a specific date. Ex: '2006-01-02' or '2023-01-02T15:04:05-0700' format.
+    #[arg(long)]
+    pub commit_since: Option<String>,
+
+    /// Scan commits older than a specific date. Ex: '2006-01-02' or '2006-10-02T15:04:05-0700' format.
+    #[arg(long)]
+    pub commit_until: Option<String>,
+
+    /// Commit to start scan from
+    #[arg(long)]
+    pub commit_from: Option<String>,
+
+    /// Commit to stop scan
+    #[arg(long)]
+    pub commit_to: Option<String>,
+
+    /// Branch to scan
+    #[arg(long)]
+    pub branch: Option<String>,
+
+    /// run gitleaks on uncommitted code
+    #[arg(long,default_value = "true")]
+    pub uncommitted: bool ,
+
+    /// user to scan
+    #[arg(long)]
+    pub user: Option<String>,
+    // /// Config path..
+    // #[arg(short = 'c', long, default_value = "gitleaks.toml")]
+    // pub config: String,
+
+    // /// Path to write json leaks file.
+    // #[arg(short = 'o', long, default_value = "")]
+    // pub report: String,
+
+    // /// Show verbose output from scan.
+    // #[arg(short = 'v', long, default_value = "false")]
+    // pub verbose: bool,
+
+    // /// Pretty print json if leaks are present.
+    // #[arg(short = 'e', long, default_value = "false")]
+    // pub pretty: bool,
+}
+
+#[derive(Debug)]
+pub struct CommitInfo {
+    pub repo: String,
+    pub commit: git2::Oid,
+    pub author: String,
+    pub email: String,
+    pub commit_message: String,
+    pub date: DateTime<FixedOffset>,
+    pub files: Vec<(String, String)>,
+    pub tags: Vec<String>,
+    pub operation: String,
+}
+/// # An array of tables that contain information that define instructions on how to detect secrets.
+#[derive(Debug)]
+pub struct Rule {
+    /// Short human readable description of the rule.
+    pub description: String,
+
+    /// Unique identifier for this rule.
+    pub id: String,
+
+    /// Regular expression used to detect secrets.
+    pub regex: String,
+
+    /// Float representing the minimum shannon entropy a regex group must have to be considered a secret.
+    pub entropy: Option<f64>,
+
+    /// Keywords are used for pre-regex check filtering. Rules that contain keywords will perform a quick string compare check to make sure the keyword(s) are in the content being scanned. Ideally these values should either be part of the idenitifer or unique strings specific to the rule's regex
+    pub keywords: Vec<String>,
+
+    /// You can include an allowlist table for a single rule to reduce false positives or ignore commits with known/rotated secrets.
+    pub allowlist: Option<Allowlist>,
+}
+
+impl Rule {
+    pub fn new() -> Rule{
+        Rule{
+            description: String::from("11"),
+            id:  String::from("11"),
+            regex:  String::from("11"),
+            entropy: Some(3.1),
+            keywords: Vec::new(),
+            allowlist: None
+        }
+    }
+}
+
+impl Default for Rule {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+/// Skip the allowlist file
+#[derive(Debug, Deserialize)]
+pub struct Allowlist {
+    /// Skip the paths.
+    pub paths: Vec<String>,
+
+    /// Skip the commits.
+    pub commits: Vec<String>,
+
+    /// Acceptable values for regexTarget are "match" and "line".
+    pub regex_target: String,
+
+    /// Skip the secrets that satisfy the regexes.
+    pub regexes: Vec<String>,
+
+    /// Skip the secrets that contain the stopwords.
+    pub stopwords: Vec<String>,
+}
+impl Allowlist {
+    pub fn new() -> Allowlist {
+        Allowlist {
+            paths: Vec::new(),
+            commits: Vec::new(),
+            regex_target: String::from("match"),
+            regexes: Vec::new(),
+            stopwords: Vec::new(),
+        }
+    }
+}
+impl Default for Allowlist {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+/// Represents an item in the scanned output.
+#[derive(Debug, Serialize, Deserialize)]
+pub struct OutputItem {
+    /// The line containing the sensitive information.
+    pub line: String,
+
+    /// The line number where the sensitive information is found.
+    pub line_number: u32,
+
+    /// The sensitive information detected.
+    pub secret: String,
+
+    /// The entropy of the sensitive information.
+    pub entropy: String,
+
+    /// The commit info.
+    pub commit: String,
+
+    /// The repository where the sensitive information is found.
+    pub repo: String,
+
+    /// The rule used to detect the sensitive information.
+    pub rule: String,
+
+    /// The commit message associated with the sensitive information.
+    pub commit_message: String,
+
+    /// The author of the commit.
+    pub author: String,
+
+    /// The email of the commit author.
+    pub email: String,
+
+    /// The file path where the sensitive information is found.
+    pub file: String,
+
+    /// The date of the commit.
+    pub date: String,
+
+    /// Tags .
+    pub tags: String,
+
+    /// The operation .
+    pub operation: String,
+}
diff --git a/src/options.rs b/src/options.rs
new file mode 100644
index 0000000..57c8803
--- /dev/null
+++ b/src/options.rs
@@ -0,0 +1,72 @@
+//! Options parsing and configuration for command line interfaces.
+use clap::{App, AppSettings, Arg};
+use std::ffi::OsString;
+use std::path::PathBuf;
+
+use crate::cleaner::*;
+
+/// Options struct to store configuration state.
+pub struct Options {
+    pub(crate) cleaners: Vec<Box<dyn Cleaner>>,
+    pub(crate) locations: Vec<PathBuf>,
+}
+
+impl Options {
+    /// Creates an `Options` struct from an iterable set of arguments.
+    pub fn from<I, T>(args: I) -> Options
+    where
+        I: IntoIterator<Item = T>,
+        T: Into<OsString> + Clone,
+    {
+        // create a new parser for our args
+        let parser = Options::create_parser();
+
+        // parse out the arguments into matching opts
+        let options = parser.get_matches_from(args);
+
+        // create opts
+        Options {
+            cleaners: vec![
+                Box::new(GitCleaner),
+                Box::new(GnostrCleaner),
+                Box::new(GradleCleaner),
+                Box::new(MakeFileCleaner),
+                Box::new(MixCleaner),
+                Box::new(NodeCleaner),
+                Box::new(MavenCleaner),
+                Box::new(CargoCleaner),
+                Box::new(RustupCleaner),
+                Box::new(MacosCleaner),
+            ],
+            locations: options
+                .values_of("locations")
+                .unwrap()
+                .filter_map(|location| PathBuf::from(location).canonicalize().ok())
+                .collect(),
+        }
+    }
+
+    /// Creates a parser used to generate `Options`.
+    fn create_parser<'a, 'b>() -> App<'a, 'b> {
+        App::new("")
+            // package metadata from cargo
+            .name(env!("CARGO_PKG_NAME"))
+            .about(env!("CARGO_PKG_DESCRIPTION"))
+            .version(env!("CARGO_PKG_VERSION"))
+            // arguments and flag details
+            .args(&[
+                // inputs: +required +multiple
+                Arg::with_name("locations")
+                    .help("Locations to search for cleanup")
+                    .multiple(true)
+                    .required(true)
+                    .default_value("."),
+            ])
+            // settings required for parsing
+            .settings(&[
+                AppSettings::ArgRequiredElseHelp,
+                AppSettings::HidePossibleValuesInHelp,
+                AppSettings::TrailingVarArg,
+            ])
+    }
+}
